# Issue: Create error recovery script

## Overview
# Issue #004.1: Create error recovery script

## Overview
Create a comprehensive error recovery script that provides cleanup mechanisms, state validation, and recovery procedures for failed PRD operations.

## Files to Modify
1. `.claude/scripts/cccc/error-recovery.sh` (new)

## Implementation Sketch

```bash
#!/bin/bash
# error-recovery.sh - Comprehensive error recovery for CCCC operations

# Recovery constants
BACKUP_DIR=".cccc/.recovery-backups"
TEMP_DIR="/tmp/cccc-recovery"
LOG_FILE=".cccc/recovery.log"

# Initialize recovery environment
init_recovery() {
    local operation="$1"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    echo "üîß Initializing recovery for operation: $operation"
    
    # Ensure backup directory exists
    mkdir -p "$BACKUP_DIR" || {
        echo "‚ùå Failed to create backup directory"
        return 1
    }
    
    # Log recovery start
    echo "[$timestamp] Recovery started for: $operation" >> "$LOG_FILE"
    return 0
}

# Create backup before risky operations
create_backup() {
    local target_path="$1"
    local backup_name="$2"
    local timestamp=$(date -u +"%Y%m%d_%H%M%S")
    
    if [[ -e "$target_path" ]]; then
        local backup_path="$BACKUP_DIR/${backup_name}_${timestamp}"
        
        echo "üíæ Creating backup: $backup_path"
        cp -r "$target_path" "$backup_path" || {
            echo "‚ùå Failed to create backup of: $target_path"
            return 1
        }
        
        echo "‚úÖ Backup created: $backup_path"
        echo "$backup_path" # Return backup path for caller
    fi
    
    return 0
}

# Recover PRD creation failures
recover_prd_creation() {
    local prd_name="$1"
    local prd_path=".cccc/prds/${prd_name}.md"
    
    echo "üîÑ Recovering PRD creation for: $prd_name"
    
    # Check if partial PRD exists
    if [[ -f "$prd_path" ]]; then
        # Validate the partial PRD
        if ! validate_yaml_frontmatter "$prd_path" 2>/dev/null; then
            echo "üóëÔ∏è Removing corrupted PRD file: $prd_path"
            rm -f "$prd_path"
            echo "‚úÖ Corrupted PRD removed"
        else
            echo "‚ö†Ô∏è Partial PRD exists and appears valid"
            echo "üí° You may want to complete or remove it manually"
        fi
    fi
    
    # Restore from backup if available
    local latest_backup=$(ls -t "$BACKUP_DIR"/*prd* 2>/dev/null | head -1)
    if [[ -n "$latest_backup" && -f "$latest_backup" ]]; then
        echo "üîÑ Latest PRD backup found: $latest_backup"
        read -p "Restore from backup? (yes/no): " confirm
        if [[ "$confirm" == "yes" ]]; then
            cp "$latest_backup" "$prd_path"
            echo "‚úÖ PRD restored from backup"
        fi
    fi
    
    return 0
}

# Recover PRD parsing failures  
recover_prd_parsing() {
    local prd_name="$1"
    local epic_dir=".cccc/epics/$prd_name"
    
    echo "üîÑ Recovering PRD parsing for: $prd_name"
    
    # Check if partial epic directory exists
    if [[ -d "$epic_dir" ]]; then
        echo "üóëÔ∏è Removing partial epic directory: $epic_dir"
        rm -rf "$epic_dir"
        echo "‚úÖ Partial epic directory removed"
    fi
    
    # Validate source PRD still exists and is valid
    local prd_path=".cccc/prds/${prd_name}.md"
    if [[ -f "$prd_path" ]]; then
        if validate_yaml_frontmatter "$prd_path" 2>/dev/null; then
            echo "‚úÖ Source PRD is valid: $prd_path"
            echo "üí° You can retry parsing with: /cccc:prd:parse $prd_name"
        else
            echo "‚ùå Source PRD is corrupted: $prd_path"
            echo "üí° Fix the PRD frontmatter before retrying"
        fi
    else
        echo "‚ùå Source PRD missing: $prd_path"
        echo "üí° Recreate the PRD with: /cccc:prd:new $prd_name"
    fi
    
    return 0
}

# Validate system state after recovery
validate_system_state() {
    echo "üîç Validating system state..."
    
    local errors=0
    
    # Check directory structure
    local required_dirs=(".cccc" ".cccc/prds" ".cccc/epics" ".claude")
    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            echo "‚ùå Missing directory: $dir"
            mkdir -p "$dir" && echo "üîß Created directory: $dir" || ((errors++))
        fi
    done
    
    # Check for orphaned files
    if [[ -n "$(find .cccc -name "*.tmp" -o -name "*.bak" 2>/dev/null)" ]]; then
        echo "‚ö†Ô∏è Temporary files found:"
        find .cccc -name "*.tmp" -o -name "*.bak" 2>/dev/null | sed 's/^/   ‚Ä¢ /'
        read -p "Remove temporary files? (yes/no): " confirm
        if [[ "$confirm" == "yes" ]]; then
            find .cccc -name "*.tmp" -o -name "*.bak" -delete
            echo "‚úÖ Temporary files cleaned up"
        fi
    fi
    
    # Validate PRD files
    local invalid_prds=0
    for prd_file in .cccc/prds/*.md 2>/dev/null; do
        [[ -f "$prd_file" ]] || continue
        if ! validate_yaml_frontmatter "$prd_file" 2>/dev/null; then
            echo "‚ùå Invalid PRD: $prd_file"
            ((invalid_prds++))
        fi
    done
    
    if [[ $invalid_prds -gt 0 ]]; then
        echo "‚ö†Ô∏è Found $invalid_prds invalid PRD files"
        echo "üí° Use validation tools to fix PRD frontmatter"
    fi
    
    if [[ $errors -eq 0 && $invalid_prds -eq 0 ]]; then
        echo "‚úÖ System state is healthy"
        return 0
    else
        echo "‚ö†Ô∏è System state has issues (errors: $errors, invalid PRDs: $invalid_prds)"
        return 1
    fi
}

# Main recovery interface
main() {
    local operation="$1"
    local target="$2"
    
    if [[ -z "$operation" ]]; then
        echo "Usage: $0 <operation> [target]"
        echo "Operations: prd-creation, prd-parsing, validate-state"
        return 1
    fi
    
    init_recovery "$operation"
    
    case "$operation" in
        "prd-creation")
            recover_prd_creation "$target"
            ;;
        "prd-parsing")
            recover_prd_parsing "$target"
            ;;
        "validate-state")
            validate_system_state
            ;;
        *)
            echo "‚ùå Unknown operation: $operation"
            return 1
            ;;
    esac
    
    local recovery_result=$?
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    echo "[$timestamp] Recovery completed for: $operation (exit code: $recovery_result)" >> "$LOG_FILE"
    
    return $recovery_result
}

# Source validation functions if available
if [[ -f "$(dirname "$0")/validate-prd.sh" ]]; then
    source "$(dirname "$0")/validate-prd.sh"
fi

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

## Acceptance Criteria
- [ ] Script provides recovery for PRD creation failures
- [ ] Script provides recovery for PRD parsing failures
- [ ] Script includes backup creation and restoration
- [ ] Script validates system state after recovery
- [ ] Script handles cleanup of partial/corrupted files
- [ ] Script provides clear recovery guidance
- [ ] Script logs all recovery operations
- [ ] Script can be run independently or sourced

## Dependencies
- Issue #001.2: Test workflow runner must exist for integration

## Definition of Done
- [ ] Code implemented according to implementation sketch
- [ ] All acceptance criteria met
- [ ] Script follows CCCC bash patterns and standards
- [ ] Comprehensive error recovery for all failure scenarios
- [ ] Ready for integration with command error handling (Issues #004.2, #004.3)\n\n---\nDepends on #36

## Comments Processing Summary
2025-08-28T11:37:28Z: Updated from platform

### Structured Updates Applied:


**jeunesse.paulien** (2025-08-28T04:42:33.417Z):
mentioned in issue #45


---
*Last updated from platform: 2025-08-28T11:37:28Z*
